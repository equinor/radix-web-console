apiVersion: radix.equinor.com/v1
kind: RadixApplication
metadata:
  name: radix-web-console
spec:
  environments:
    - name: dev
      authorization:
      - role: RadixAppAdmin
        groups:
        - "fg_radix_platform_development"
    - name: prod
      authorization:
      - role: RadixAppAdmin
        groups:
        - "fg_radix_platform_development"
  components:
    - name: web
      src: "."
      ports:
       - 80
      public: true
  pipelines:

    # Human-readable name for pipeline
    - name: "Build and deploy master to Dev"
      # This must be a known pipeline type; each type has some required
      # properties; e.g. this requires an input of code (provided by the
      # trigger) and a target environment (provided by the "deploy_to")
      # property
      type: "build_deploy"
      # Where to deploy (could also be a list)
      deploy_to: "dev"
      # What triggers this pipeline
      trigger:
        # This must be a known trigger type; each trigger type might produce an
        # "output" to be fed into the pipeline (in this case, a directory with
        # checked-out code). Different types of trigger would have different
        # properties
        type: "commit"
        # For the "commit" trigger type, we could allow a list of branches, but
        # supporting a simple branch name will probably solve most use cases
        on_branch: "master"

    # This pipeline builds on any PR to any branch
    - name: "Build PRs to any branch"
      # Again, a known pipeline type. We will code these "types" and define
      # their behaviour
      type: "build"
      trigger:
        # Same for trigger types
        type: "pr"
        on_branch: "*"

    # This is a manually-tiggered pipeline. The trigger type requires some user
    # input to be provided via the web console or the CLI when invoking the
    # pipeline. In this case the trigger expects something that it can check out
    # and pass to the pipeline (which expects a code tree to build). The trigger
    # could receive anything that resolves to a commit (e.g. a branch, a tag,
    # or a specific commit). Examples:
    #
    # `radix run-pipeline "Deploy to QA" --triggerParams=commit:50d59c8a5d6`
    # `radix run-pipeline "Deploy to QA" --triggerParams=commit:develop@{yesterday}`
    # `radix run-pipeline "Deploy to QA" --triggerParams=commit:master`
    # `radix run-pipeline "Deploy to QA" --triggerParams=commit:release-1.2.3`
    - name: "Deploy to QA"
      type: "build_deploy"
      deploy_to: "qa"
      trigger:
        type: "provided_commit"

    # As above. Note that the trigger is reused (so, that would be the same
    # backend code), but the pipeline itself is different. In this case it would
    # build and create docker images, place them in the docker repo with the
    # tag "next_release", and create (but not deploy) a Radix deployment object.
    #
    # Different internal steps within a pipeline can be bits of reusable code
    # (steps) — so the build step of "build_image" and the build step of
    # "build_deploy" can be the exact same thing
    #
    # `radix run-pipeline "Build next release" --triggerParams=commit:master`
    - name: "Build next release"
      type: "build_images"
      tags:
        - "next_release"
      trigger:
        type: "provided_commit"

    # In this case the trigger needs a Radix deployment to be provided (like
    # the one created by "build_images", above)
    #
    # `radix run-pipeline "Deploy to Prod" --triggerParams=deployment:next_release"
    - name: "Deploy to Prod"
      type: "deploy"
      deploy_to: "prod"
      trigger:
        type: "provided_deployment"
